import { Request } from "../models/Request.js";
import { RequestCluster } from "../models/RequestCluster.js";

const CLUSTER_RADIUS = 500; // 500 meters
const SIMILARITY_THRESHOLD = 0.6; // 60% similarity

/**
 * Calculate distance between two coordinates using Haversine formula
 */
function calculateDistance(coords1, coords2) {
  const [lon1, lat1] = coords1;
  const [lon2, lat2] = coords2;

  const R = 6371e3; // Earth radius in meters
  const φ1 = (lat1 * Math.PI) / 180;
  const φ2 = (lat2 * Math.PI) / 180;
  const Δφ = ((lat2 - lat1) * Math.PI) / 180;
  const Δλ = ((lon2 - lon1) * Math.PI) / 180;

  const a =
    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}

/**
 * Calculate similarity between two requests based on needs
 */
function calculateSimilarity(request1, request2) {
  const needs1 = Object.keys(request1.needs || {}).filter(
    (k) => request1.needs[k]?.required
  );
  const needs2 = Object.keys(request2.needs || {}).filter(
    (k) => request2.needs[k]?.required
  );

  if (needs1.length === 0 && needs2.length === 0) return 1;
  if (needs1.length === 0 || needs2.length === 0) return 0;

  const commonNeeds = needs1.filter((need) => needs2.includes(need));
  const totalUniqueNeeds = new Set([...needs1, ...needs2]).size;

  return commonNeeds.length / totalUniqueNeeds;
}

/**
 * Calculate centroid of multiple coordinates
 */
function calculateCentroid(coordinates) {
  if (coordinates.length === 0) return [0, 0];
  if (coordinates.length === 1) return coordinates[0];

  let x = 0,
    y = 0,
    z = 0;

  coordinates.forEach(([lon, lat]) => {
    const latRad = (lat * Math.PI) / 180;
    const lonRad = (lon * Math.PI) / 180;

    x += Math.cos(latRad) * Math.cos(lonRad);
    y += Math.cos(latRad) * Math.sin(lonRad);
    z += Math.sin(latRad);
  });

  x /= coordinates.length;
  y /= coordinates.length;
  z /= coordinates.length;

  const lonRad = Math.atan2(y, x);
  const hyp = Math.sqrt(x * x + y * y);
  const latRad = Math.atan2(z, hyp);

  return [(lonRad * 180) / Math.PI, (latRad * 180) / Math.PI];
}

/**
 * Find or create cluster for a request
 */
export async function findOrCreateCluster(requestId) {
  try {
    const request = await Request.findById(requestId);
    if (!request || !request.location?.coordinates) {
      return null;
    }

    // Check if already in a cluster
    if (request.clusterId) {
      return await RequestCluster.findById(request.clusterId);
    }

    const requestCoords = request.location.coordinates;

    // Find nearby requests (within CLUSTER_RADIUS)
    const nearbyRequests = await Request.find({
      _id: { $ne: requestId },
      status: { $in: ["new", "triaged"] },
      clusterId: null,
      "location.coordinates": {
        $near: {
          $geometry: {
            type: "Point",
            coordinates: requestCoords,
          },
          $maxDistance: CLUSTER_RADIUS,
        },
      },
    }).limit(20);

    // Filter by similarity
    const similarRequests = nearbyRequests.filter((req) => {
      const similarity = calculateSimilarity(request, req);
      return similarity >= SIMILARITY_THRESHOLD;
    });

    // If no similar requests, don't create cluster
    if (similarRequests.length === 0) {
      return null;
    }

    // Create new cluster
    const allRequests = [request, ...similarRequests];
    const allCoordinates = allRequests.map((r) => r.location.coordinates);
    const centroid = calculateCentroid(allCoordinates);

    const cluster = new RequestCluster({
      leadRequest: requestId,
      requests: allRequests.map((r) => r._id),
      location: {
        type: "Point",
        coordinates: centroid,
        area: request.location.area,
      },
      radius: CLUSTER_RADIUS,
      clusteringMethod: "proximity",
      autoGenerated: true,
    });

    await cluster.save();
    await cluster.recalculate();
    await cluster.save();

    // Update all requests with cluster ID
    await Request.updateMany(
      { _id: { $in: allRequests.map((r) => r._id) } },
      { clusterId: cluster._id }
    );

    // Mark lead request
    await Request.findByIdAndUpdate(requestId, { isClusterLead: true });

    console.log(`Created cluster ${cluster._id} with ${allRequests.length} requests`);

    return cluster;
  } catch (error) {
    console.error("Error in findOrCreateCluster:", error);
    return null;
  }
}

/**
 * Recalculate all active clusters
 */
export async function recalculateAllClusters() {
  try {
    const clusters = await RequestCluster.find({
      status: { $in: ["active", "assigned", "in-progress"] },
    });

    for (const cluster of clusters) {
      await cluster.recalculate();
      await cluster.save();
    }

    console.log(`Recalculated ${clusters.length} clusters`);
  } catch (error) {
    console.error("Error recalculating clusters:", error);
  }
}

/**
 * Dissolve cluster if requests are fulfilled or cancelled
 */
export async function checkAndDissolveCluster(clusterId) {
  try {
    const cluster = await RequestCluster.findById(clusterId);
    if (!cluster) return;

    const requests = await Request.find({ _id: { $in: cluster.requests } });

    // Check if all requests are fulfilled or cancelled
    const activeRequests = requests.filter((r) =>
      ["new", "triaged", "assigned", "in-progress"].includes(r.status)
    );

    if (activeRequests.length === 0) {
      cluster.status = "dissolved";
      await cluster.save();

      // Clear cluster ID from requests
      await Request.updateMany(
        { _id: { $in: cluster.requests } },
        { clusterId: null, isClusterLead: false }
      );

      console.log(`Dissolved cluster ${clusterId}`);
    }
  } catch (error) {
    console.error("Error dissolving cluster:", error);
  }
}

/**
 * Find clusters in a specific area
 */
export async function findClustersInArea(coordinates, radius = 50000) {
  try {
    const clusters = await RequestCluster.find({
      status: { $in: ["active", "assigned", "in-progress"] },
      "location.coordinates": {
        $near: {
          $geometry: {
            type: "Point",
            coordinates,
          },
          $maxDistance: radius,
        },
      },
    }).populate("leadRequest", "priority sosDetected");

    return clusters;
  } catch (error) {
    console.error("Error finding clusters:", error);
    return [];
  }
}

/**
 * Get cluster statistics
 */
export async function getClusterStats() {
  try {
    const stats = await RequestCluster.aggregate([
      {
        $match: {
          status: { $in: ["active", "assigned", "in-progress"] },
        },
      },
      {
        $group: {
          _id: "$priority",
          count: { $sum: 1 },
          totalBeneficiaries: { $sum: "$totalBeneficiaries.total" },
          avgRadius: { $avg: "$radius" },
        },
      },
    ]);

    return stats;
  } catch (error) {
    console.error("Error getting cluster stats:", error);
    return [];
  }
}
