import mongoose from "mongoose";

const requestClusterSchema = new mongoose.Schema(
  {
    // Cluster identification
    clusterName: String,
    
    // Lead request
    leadRequest: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Request",
      required: true,
    },
    
    // Member requests
    requests: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: "Request",
    }],
    
    // Cluster location (centroid)
    location: {
      type: {
        type: String,
        enum: ["Point"],
        default: "Point",
      },
      coordinates: {
        type: [Number],
        required: true,
      },
      address: String,
      area: String,
    },
    
    // Cluster radius
    radius: {
      type: Number,
      default: 500, // 500 meters
    },
    
    // Aggregated data
    aggregatedNeeds: {
      rescue: { count: Number, urgency: String },
      food: { count: Number, quantity: Number },
      water: { count: Number, quantity: Number },
      medical: { count: Number, urgency: String },
      babySupplies: { count: Number },
      sanitation: { count: Number },
      shelter: { count: Number, capacity: Number },
      power: { count: Number },
      transport: { count: Number },
    },
    
    totalBeneficiaries: {
      adults: { type: Number, default: 0 },
      children: { type: Number, default: 0 },
      elderly: { type: Number, default: 0 },
      infants: { type: Number, default: 0 },
      total: { type: Number, default: 0 },
    },
    
    // Priority
    priority: {
      type: String,
      enum: ["low", "medium", "high", "critical", "sos"],
      default: "medium",
    },
    highestPriority: String,
    sosCount: {
      type: Number,
      default: 0,
    },
    
    // Status
    status: {
      type: String,
      enum: ["active", "assigned", "in-progress", "fulfilled", "dissolved"],
      default: "active",
    },
    
    // Assignment
    assignments: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: "Assignment",
    }],
    
    // Clustering metadata
    clusteringMethod: {
      type: String,
      enum: ["proximity", "similarity", "manual"],
      default: "proximity",
    },
    clusteringScore: Number,
    
    // Created by
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    autoGenerated: {
      type: Boolean,
      default: true,
    },
    
    // Verification
    isVerified: {
      type: Boolean,
      default: false,
    },
    verifiedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    
    // Notes
    notes: String,
    
    // Last updated
    lastActivity: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes
requestClusterSchema.index({ "location.coordinates": "2dsphere" });
requestClusterSchema.index({ status: 1, priority: 1 });
requestClusterSchema.index({ leadRequest: 1 });

// Calculate aggregated data
requestClusterSchema.methods.recalculate = async function() {
  const Request = mongoose.model("Request");
  const requests = await Request.find({ _id: { $in: this.requests } });
  
  // Reset aggregated needs
  this.aggregatedNeeds = {
    rescue: { count: 0, urgency: "low" },
    food: { count: 0, quantity: 0 },
    water: { count: 0, quantity: 0 },
    medical: { count: 0, urgency: "low" },
    babySupplies: { count: 0 },
    sanitation: { count: 0 },
    shelter: { count: 0, capacity: 0 },
    power: { count: 0 },
    transport: { count: 0 },
  };
  
  this.totalBeneficiaries = {
    adults: 0,
    children: 0,
    elderly: 0,
    infants: 0,
    total: 0,
  };
  
  let highestPriorityScore = 0;
  const priorityScores = { low: 1, medium: 2, high: 3, critical: 4, sos: 5 };
  this.sosCount = 0;
  
  requests.forEach(req => {
    // Aggregate needs
    Object.keys(req.needs || {}).forEach(need => {
      if (req.needs[need]?.required) {
        this.aggregatedNeeds[need].count++;
        if (req.needs[need].quantity) {
          this.aggregatedNeeds[need].quantity = (this.aggregatedNeeds[need].quantity || 0) + req.needs[need].quantity;
        }
        if (req.needs[need].urgency) {
          const currentUrgency = this.aggregatedNeeds[need].urgency || "low";
          if (priorityScores[req.needs[need].urgency] > priorityScores[currentUrgency]) {
            this.aggregatedNeeds[need].urgency = req.needs[need].urgency;
          }
        }
      }
    });
    
    // Aggregate beneficiaries
    if (req.beneficiaries) {
      this.totalBeneficiaries.adults += req.beneficiaries.adults || 0;
      this.totalBeneficiaries.children += req.beneficiaries.children || 0;
      this.totalBeneficiaries.elderly += req.beneficiaries.elderly || 0;
      this.totalBeneficiaries.infants += req.beneficiaries.infants || 0;
      this.totalBeneficiaries.total += req.beneficiaries.total || 0;
    }
    
    // Track highest priority
    const reqPriorityScore = priorityScores[req.priority] || 0;
    if (reqPriorityScore > highestPriorityScore) {
      highestPriorityScore = reqPriorityScore;
      this.highestPriority = req.priority;
    }
    
    if (req.sosDetected) {
      this.sosCount++;
    }
  });
  
  // Set cluster priority
  this.priority = this.highestPriority;
};

export const RequestCluster = mongoose.model("RequestCluster", requestClusterSchema);
